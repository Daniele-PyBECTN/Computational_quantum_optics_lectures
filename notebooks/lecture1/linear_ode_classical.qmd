---
title: One-Dimensional Case
---

```{python}
import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
import scipy.sparse as sparse
import functools as ft
```

```{python}
def gaussian(x, mu, sigma):
    """Generate a Gaussian function."""
    return np.exp(-0.5 * ((x - mu) / sigma) ** 2) / (sigma * np.sqrt(2 * np.pi))
```



```{python}
N_x = 101
N_px = 101
x_bound = 2
px_bound = 2

# Identity matrices for the different dimensions
Ix = sparse.eye(N_x)
Ipx = sparse.eye(N_px)

x_list = np.linspace(-x_bound, x_bound, N_x)
px_list = np.linspace(-px_bound, px_bound, N_px)

dx = x_list[1] - x_list[0]
dpx = px_list[1] - px_list[0]

# Define the operators
x_op = sparse.diags(x_list)
px_op = sparse.diags(px_list)

# Use central differences for derivatives
d_x_op = sparse.diags([np.ones(N_x-1)/(2*dx), -np.ones(N_x-1)/(2*dx)], offsets=[1, -1])
d_px_op = sparse.diags([np.ones(N_px-1)/(2*dpx), -np.ones(N_px-1)/(2*dpx)], offsets=[1, -1])

# Create the full operator for the 4D phase space
x = ft.reduce(sparse.kron, [x_op, Ipx]).todia()
px = ft.reduce(sparse.kron, [Ix, px_op]).todia()

d_x = ft.reduce(sparse.kron, [d_x_op, Ipx]).todia()
d_px = ft.reduce(sparse.kron, [Ix, d_px_op]).todia()
```

We now have an Hamiltonian of the form

$$
H = \frac{p^2}{2m} + V(x)
$$

And the Liouville equation is

$$
\frac{\partial \rho}{\partial t} = \{H, \rho\} = \mathcal{L}(\rho)
$$

where $\rho$ is the density operator, $\mathcal{L}$ is the Liouville operator, and $\{A, B\}$ is the Poisson bracket defined as

$$
\{A, B\} = \left( \frac{\partial A}{\partial x} \frac{\partial B}{\partial p} - \frac{\partial A}{\partial p} \frac{\partial B}{\partial x} \right)
$$

Thus, in our case, the Liouville operation becomes

$$
\mathcal{L} = \frac{\partial V}{\partial x} \frac{\partial}{\partial p} - \frac{p}{m} \frac{\partial}{\partial x}
$$


For $V(x, y) = \frac{1}{2} k x^2 + G x^4$, the derivative becomes

$$
\frac{\partial V}{\partial x} = k x + 4 G x^3
$$

```{python}
m = 0.5 # Mass of the particle
k = 2.0 # Spring constant
G = 0.3 # Nonlinear constant

dV_dx = k * x + 4 * G * x @ x @ x

# Liouville operator
L = dV_dx @ d_px - (px / m) @ d_x

t_list = np.linspace(0, 2, 50000)

# Initial state: we will use a Gaussian wave packet to avoid singularities
x_0 = np.sqrt(gaussian(x_list, 0.5, 0.2)) * np.sqrt(dx)
p_0 = np.sqrt(gaussian(px_list, 0.1, 0.2)) * np.sqrt(dpx)
rho_0 = np.kron(x_0, p_0)

x_t = np.zeros(t_list.shape[0])
v_t = np.zeros(t_list.shape[0])
E_t = np.zeros(t_list.shape[0])

x_t[0] = rho_0.dot(x.dot(rho_0))
v_t[0] = rho_0.dot(px.dot(rho_0)) / m
E_t[0] = (0.5 * m * v_t[0]**2 + 0.5 * k * x_t[0]**2 + G * x_t[0]**4)

rho_t = [rho_0.copy()]
for i, t in enumerate(t_list[1:], 1):
    drho_dt = L @ rho_t[-1]
    rho_t.append(rho_t[-1] + drho_dt * (t_list[1] - t_list[0]))  # Simple Euler integration
    x_t[i] = rho_t[-1].dot(x.dot(rho_t[-1]))
    v_t[i] = rho_t[-1].dot(px.dot(rho_t[-1])) / m
    E_t[i] = (0.5 * m * v_t[i]**2 + 0.5 * k * x_t[i]**2 + G * x_t[i]**4)
```

```{python}
fig, ax = plt.subplots()

ax.plot(t_list, x_t, label=r'$x(t)$')
ax.plot(t_list, v_t, label=r'$v(t)$')
ax.plot(t_list, E_t, label=r'$E(t)$', linestyle='--')

ax.set_xlabel('Time')
ax.set_ylabel('Position / Momentum / Energy')
ax.legend()
```

```{python}
from IPython.display import HTML
from matplotlib.animation import FuncAnimation

fig, ax = plt.subplots()

img = ax.pcolormesh(x_list, px_list, rho_t[0].reshape(N_x, N_px)**2, shading='gouraud')
ax.set_xlabel('Position $x$')
ax.set_ylabel('Momentum $p_x$')

def animate(i):
    img.set_array(rho_t[i]**2)
    return img,

ani = FuncAnimation(fig, animate, frames=range(0, len(t_list), 500), interval=50, blit=True)

HTML(ani.to_jshtml())
```


